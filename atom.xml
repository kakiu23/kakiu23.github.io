<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Q鸽博客</title>
  
  <subtitle>Stay Hungry Stay Foolish</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-07-03T15:21:33.843Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Q鸽</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows系统安装Oracle GraalVM保姆级教程</title>
    <link href="http://example.com/2024/04/28/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Oracle-GraalVM%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2024/04/28/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Oracle-GraalVM%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/</id>
    <published>2024-04-28T14:43:03.000Z</published>
    <updated>2024-07-03T15:21:33.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Oracle-GraalVM？"><a href="#1-什么是Oracle-GraalVM？" class="headerlink" title="1. 什么是Oracle GraalVM？"></a>1. 什么是Oracle GraalVM？</h1><p>Oracle GraalVM 是一个使用即时 (JIT) 编译器加速 Java 和 JVM 应用性能的高性能 JDK。它由 Oracle 提供 24/7 支持，能够降低应用延迟，通过缩短垃圾回收时间提高峰值吞吐量。</p><p>此外，GraalVM 本地镜像实用程序可提前 (AOT) 编译 Java 字节码，生成可近乎瞬时启动且仅占用极少内存资源的本机可执行文件。</p><h1 id="2-为什么要使用Oracle-GraalVM？"><a href="#2-为什么要使用Oracle-GraalVM？" class="headerlink" title="2. 为什么要使用Oracle GraalVM？"></a>2. 为什么要使用Oracle GraalVM？</h1><p>GraalVM 支持开发人员以更出色的隔离特性和更高的敏捷性，为云环境或混合环境构建更高效的代码。如今，越来越多的企业开始使用 GraalVM，原因如下：</p><ul><li>快速响应市场变化：如今的业务应用需要处理不断增长的数据，快速响应客户需求。而 Java 应用可以不断进化，帮助开发人员显著提升应用的性能效率，同时降低 IT 成本。</li><li>构建现代 Java 应用，通过微服务和容器来满足云原生需求：微服务是执行单一功能的小型、独立微应用。在现实中，业务应用通常要使用数百项服务，每项服务都需要快速启动，以尽可能降低延迟和云技术使用成本。而利用微服务，您只需为实际使用的资源付费。</li><li>构建一个各种编程语言基于单一 JVM 运行的生态系统，提高开发效率。</li></ul><h1 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h1><p><strong>提升性能，扩展现有 Java 应用</strong></p><p>GraalVM 创新功能可帮助 Java 代码满足当今的计算需求，以超快速性能快速响应客户需求。它可以使用高级优化器提升峰值吞吐量，还可以尽可能减少对象分配，缩短垃圾回收时间，优化内存。在 JIT 模式下，GraalVM 可提升性能高达 50%。而得益于更早释放内存，您可以在同一基础设施上运行其他工作负载，降低 IT 成本。</p><p><strong>构建云原生应用</strong></p><p>Oracle GraalVM 的本地镜像实用程序可提前将字节码 Java 应用编译为二进制机器码。与基于 JVM 运行相比，原生可执行文件的启动速度可提升近 100 倍，内存占用可降低 5 倍。</p><p><img src="/images/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Oracle-GraalVM%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/rc24-graalvm-enterprise-native.webp"></p><p>图 1：相比 Go 和 Java HotSpot，本机可执行文件可近乎瞬时启动且占用内存极少。</p><p>随着企业将工作负载迁移到云中，按小时为系统资源付费，GraalVM 可有效节约运营成本。这使 GraalVM 生成的本机可执行文件成为了微服务（由微服务框架提供支持，例如 Helidon、Micronaut、Quarkus 和 Spring Boot 等等）部署的理想选择。</p><p><strong>开发多语言程序，提高效率</strong></p><p>您可以基于 JVM，以超强性能运行 Java 以及 JavaScript 等其他语言。Oracle NetSuite SuiteScript 是一种扩展语言，支持用户对基于 NetSuite 运行的应用进行定制。Oracle GraalVM 支持 NetSuite 嵌入基于 Truffle 的 JavaScript 运行时，从而将 JavaScript 编译为运行速度比基于 JVM 的 SuiteScript 快 4 倍的机器码。</p><h1 id="4-安装"><a href="#4-安装" class="headerlink" title="4. 安装"></a>4. 安装</h1><h2 id="4-1-下载Oracle-GraalVM"><a href="#4-1-下载Oracle-GraalVM" class="headerlink" title="4.1. 下载Oracle GraalVM"></a>4.1. 下载Oracle GraalVM</h2><p>进入官网<a href="https://www.graalvm.org/downloads/">Download GraalVM</a><a href="https://www.graalvm.org/downloads/%EF%BC%8C%E9%80%89%E6%8B%A9%E7%89%88%E6%9C%AC%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%E3%80%82">https://www.graalvm.org/downloads/，选择版本进行下载。</a></p><p><img src="/images/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Oracle-GraalVM%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/image2.png"></p><p>我这里示例选择了Java21的版本下载，解压后得到文件夹如下：</p><p><img src="/images/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Oracle-GraalVM%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/image3.png"></p><h2 id="4-2-配置环境变量"><a href="#4-2-配置环境变量" class="headerlink" title="4.2. 配置环境变量"></a>4.2. 配置环境变量</h2><ol><li>设置JAVA_HOME环境变量，指向 GraalVM 安装目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setx &#x2F;M JAVA_HOME &quot;C:\Program Files (x86)\graalvm-jdk-21.0.3&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>将 GraalVM的bin目录添加到环境变量中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setx &#x2F;M PATH &quot;C:\Program Files (x86)\graalvm-jdk-21.0.3\bin;%PATH%&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>重新打开命令行窗口执行以下命令进行检查是否配置成功</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo %PATH%</span><br><span class="line">echo %JAVA_HOME%</span><br></pre></td></tr></table></figure><p>看到有上面配置的路径就证明可以了</p><p><img src="/images/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Oracle-GraalVM%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/image4.png"></p><h2 id="4-3-安装Visual-Studio"><a href="#4-3-安装Visual-Studio" class="headerlink" title="4.3. 安装Visual Studio"></a>4.3. 安装Visual Studio</h2><p>在Windows电脑上，使用GraalVM构建本机可执行程序需要安装Visual Studio 2022 版本 17.6.0 或更高版本。</p><ol><li>点击链接<a href="https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&rel=16">Your Privacy Choices Opt-Out Icon</a>下载安装程序</li></ol><p><img src="/images/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Oracle-GraalVM%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/image5.png"></p><ol start="2"><li>进入安装界面选择C++桌面开发进行安装</li></ol><p><img src="/images/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Oracle-GraalVM%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/image6.png"></p><ol start="3"><li>安装完成后重启电脑就可以使用native-image构建程序了</li></ol><h1 id="5-使用native-image构建程序"><a href="#5-使用native-image构建程序" class="headerlink" title="5. 使用native-image构建程序"></a>5. 使用native-image构建程序</h1><p>在构建之前先检查native-image是否配置好了。在cmd命令行窗口输入：native-image.cmd –version命令，看到有native-image的版本信息输出就证明是ok的。</p><p><img src="/images/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Oracle-GraalVM%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/image7.png"></p><h2 id="5-1-使用maven插件构建"><a href="#5-1-使用maven插件构建" class="headerlink" title="5.1. 使用maven插件构建"></a>5.1. 使用maven插件构建</h2><p>下面我以springboot项目为例。</p><ol><li>在pom文件中添加如下配置：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">  &lt;profile&gt;</span><br><span class="line">    &lt;id&gt;native&lt;&#x2F;id&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">      &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;groupId&gt;org.graalvm.buildtools&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;native-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;extensions&gt;true&lt;&#x2F;extensions&gt;</span><br><span class="line">          &lt;executions&gt;</span><br><span class="line">            &lt;execution&gt;</span><br><span class="line">              &lt;id&gt;build-native&lt;&#x2F;id&gt;</span><br><span class="line">              &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;compile-no-fork&lt;&#x2F;goal&gt;</span><br><span class="line">              &lt;&#x2F;goals&gt;</span><br><span class="line">              &lt;phase&gt;package&lt;&#x2F;phase&gt;</span><br><span class="line">            &lt;&#x2F;execution&gt;</span><br><span class="line">            &lt;execution&gt;</span><br><span class="line">              &lt;id&gt;test-native&lt;&#x2F;id&gt;</span><br><span class="line">              &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;test&lt;&#x2F;goal&gt;</span><br><span class="line">              &lt;&#x2F;goals&gt;</span><br><span class="line">              &lt;phase&gt;test&lt;&#x2F;phase&gt;</span><br><span class="line">            &lt;&#x2F;execution&gt;</span><br><span class="line">          &lt;&#x2F;executions&gt;</span><br><span class="line">          &lt;configuration&gt;</span><br><span class="line">            &lt;!-- ... --&gt;</span><br><span class="line">          &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">      &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">  &lt;&#x2F;profile&gt;</span><br><span class="line">&lt;&#x2F;profiles&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>选择native profile进行打包</li></ol><p><img src="/images/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Oracle-GraalVM%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/image8.png"></p><ol start="3"><li>编译打包完成后在项目的target目录下会生成一个可执行文件exe</li></ol><p><img src="/images/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Oracle-GraalVM%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/image9.png"></p><ol start="4"><li>双击就可以启动程序了</li></ol><p><img src="/images/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Oracle-GraalVM%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/image10.png"></p><p>注：插件还有很多可配置的参数，在这里就不一一讲解，有需要的请参考官方文档：<a href="https://graalvm.github.io/native-build-tools/latest/maven-plugin.html">Maven plugin for GraalVM Native Image building</a></p><h1 id="6-实际使用对比"><a href="#6-实际使用对比" class="headerlink" title="6. 实际使用对比"></a>6. 实际使用对比</h1><ol><li>使用JVM启动，启动耗时1.5s，内存占用约：142MB</li></ol><p><img src="/images/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Oracle-GraalVM%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/image11.png"></p><p><img src="/images/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Oracle-GraalVM%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/image12.png"></p><ol start="2"><li>使用native-image构建的二进制文件启动，启动耗时0.1s，内存占用29MB</li></ol><p><img src="/images/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Oracle-GraalVM%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/image13.png"></p><p><img src="/images/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Oracle-GraalVM%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/image14.png"></p><ol start="3"><li>结论：通过上面的数据对比，启动速度快了15倍，内存占用减少将近5倍。</li></ol><p>注：因为我演示的是demo项目，没什么代码量，启动速度和内存的对比仅作参考，实际项目的启动速度提升倍数可能更大（官方宣称启动速度可提升近 100 倍，内存占用可降低 5 倍）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-什么是Oracle-GraalVM？&quot;&gt;&lt;a href=&quot;#1-什么是Oracle-GraalVM？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是Oracle GraalVM？&quot;&gt;&lt;/a&gt;1. 什么是Oracle GraalVM？&lt;/h1</summary>
      
    
    
    
    
    <category term="GraalVM Oracle" scheme="http://example.com/tags/GraalVM-Oracle/"/>
    
  </entry>
  
  <entry>
    <title>聊聊分布式事务</title>
    <link href="http://example.com/2021/11/13/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://example.com/2021/11/13/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-11-13T08:50:00.000Z</published>
    <updated>2024-07-03T15:18:40.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务（Transaction）是并发控制单位，一个操作序列组合而成，这些操作要么都执行，要么都不执行。</p><p><strong>事务的ACID：</strong></p><ul><li>原子性（Atomicity）：一个事务的多个操作必须完成，或者都不完成</li><li>一致性（Consistency）：事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后顺序都是合法数据状态。</li><li>隔离性（Isolation）：事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持久性（Durability）：事务一旦提交，所有的修改将永久的保存到数据库中，即使系统崩溃重启后数据也不会丢失。</li></ul><h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>轻量级事务管理器，事务只在本工程内有效（不能跨工程），本地事务依赖于数据库事务。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>随着互联网的快速发展，软件系统由原来的单体应用转变为分布式应用，下图描述了单体应用向微服务的演变：</p><p><img src="/images/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image.png"></p><p>分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操</p><p>作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为<strong>分布式事务，</strong>例如注册送话费，银行转账等。</p><p>本地事务依赖数据库本身提供的事务特性来实现，因此以下逻辑可以控制本地事务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin transaction；</span><br><span class="line">&#x2F;&#x2F;1.本地数据库操作：张三减少金额</span><br><span class="line">&#x2F;&#x2F;2.本地数据库操作：李四增加金额</span><br><span class="line">commit transation;</span><br></pre></td></tr></table></figure><p>但是在分布式环境下，会变成下边这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin transaction；</span><br><span class="line">&#x2F;&#x2F;1.本地数据库操作：张三减少金额</span><br><span class="line">&#x2F;&#x2F;2.远程调用：让李四增加金额</span><br><span class="line">commit transation;</span><br></pre></td></tr></table></figure><p>当远程调用让李四增加金额成功了，由于网络问题远程调用并没有返回，此时本地事务提交失败就回滚</p><p>了张三减少金额的操作，此时张三和李四的数据就不一致了。</p><p>因此在分布式架构的基础上，传统数据库事务就无法使用了，张三和李四的账户不在一个数据库中甚至不在一个应用系统里，实现转账事务需要通过远程调用，由于网络问题就会导致分布式事务问题。</p><h3 id="分布式事务产生的场景"><a href="#分布式事务产生的场景" class="headerlink" title="分布式事务产生的场景"></a>分布式事务产生的场景</h3><ol><li>典型的场景就是微服务架构微服务之间通过远程调用完成事务操作。比如：订单微服务和库存微服务，下单的同时订单微服务请求库存微服务减库存。 简言之：跨JVM进程产生分布式事务。</li></ol><p><img src="/images/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image2.png"></p><ol start="2"><li>单体系统访问多个数据库实例 当单体系统需要访问多个数据库（实例）时就会产生分布式事务。 比如：用户信息和订单信息分别在两个MySQL实例存储，用户管理系统删除用户信息，需要分别删除用户信息及用户的订单信息，由于数据分布在不同的数据实例，需要通过不同的数据库链接去操作数据，此时产生分布式事务。 简言之：跨数据库实例产生分布式事务。</li></ol><p><img src="/images/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image3.png"></p><ol start="3"><li>多服务访问同一个数据库实例 比如：订单微服务和库存微服务即使访问同一个数据库也会产生分布式事务，原因就是跨JVM进程，两个微服务持有了不同的数据库链接进行数据库操作，此时产生分布式事务。</li></ol><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>CAP是 一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）三个词语的缩写。</p><p>下面举一个例子来理解CAP理论。</p><p>整体执行流程如下：</p><p>1、商品服务请求主数据库写入商品信息（添加商品、修改商品、删除商品）</p><p>2、主数据库向商品服务响应写入成功。</p><p>3、商品服务请求从数据库读取商品信息。</p><p><img src="/images/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image4.png"></p><p><strong>C （一致性Consistency）：</strong></p><p>一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意结点读取到的数据都是最新的状态。</p><p>上图中，商品信息的读写要满足一致性就是要实现如下目标：</p><p>商品服务写入主数据库成功，则向从数据库查询新数据也成功。</p><p>如何实现一致性？</p><p>1、写入主数据库后要将数据同步到从数据库。</p><p>2、写入主数据库后，在向从数据库同步期间要将从数据库锁定，待同步完成后再释放锁，以免在新数据写入成功后，向从数据库查询到旧的数据。</p><p><strong>分布式系统一致性的特点：</strong></p><p>1、由于存在数据同步的过程，写操作的响应会有一定的延迟。</p><p>2、为了保证数据一致性会对资源暂时锁定，待数据同步完成释放锁定资源。</p><p>3、如果请求数据同步失败的结点则会返回错误信息，一定不会返回旧数据。</p><p><strong>A （可用性Availability） ：</strong></p><p>可用性是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误。</p><p>上图中，商品信息读取满足可用性就是要实现如下目标：</p><p>1、从数据库接收到数据查询的请求则立即能够响应数据查询结果。</p><p>2、从数据库不允许出现响应超时或响应错误。</p><p>如何实现可用性？</p><p>1、写入主数据库后要将数据同步到从数据库。</p><p>2、由于要保证从数据库的可用性，不可将从数据库中的资源进行锁定。</p><p>3、即时数据还没有同步过来，从数据库也要返回要查询的数据，哪怕是旧数据，如果连旧数据也没有则可以按照约定返回一个默认信息，但不能返回错误或响应超时。</p><p>分布式系统可用性的特点：</p><p>1、 所有请求都有响应，且不会出现响应超时或响应错误。</p><p><strong>P（分区容忍性Partition tolerance）：</strong></p><p>通常分布式系统的各各结点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致结点之间通信失败，此时仍可对外提供服务，这叫分区容忍性。</p><p>上图中，商品信息读写满足分区容忍性就是要实现如下目标：</p><p>1、主数据库向从数据库同步数据失败不影响读写操作。</p><p>2、其一个结点挂掉不影响另一个结点对外提供服务。</p><p>如何实现分区容忍性？</p><p>1、尽量使用异步取代同步操作，例如使用异步方式将数据从主数据库同步到从数据，这样结点之间能有效的实现</p><p>松耦合。</p><p>2、添加从数据库结点，其中一个从结点挂掉其它从结点提供服务。</p><p>分布式分区容忍性的特点：</p><p>1、分区容忍性分是布式系统具备的基本能力。</p><h3 id="CAP组合方式"><a href="#CAP组合方式" class="headerlink" title="CAP组合方式"></a>CAP组合方式</h3><p><strong>在所有分布式事务场景中不会同时具备CAP三个特性。</strong></p><h4 id="AP"><a href="#AP" class="headerlink" title="AP"></a>AP</h4><p>放弃一致性，追求分区容忍性和可用性。这是很多分布式系统设计时的选择。</p><p>例如：</p><p>上边的商品管理，完全可以实现AP，前提是只要用户可以接受所查询的到数据在一定时间内不是最新的即可。</p><p>通常实现AP都会保证最终一致性。一些业务场景比如：订单退款，今日退款成功，明日账户到账，只要用户可以接受在一定时间内到账即可。</p><h4 id="CP"><a href="#CP" class="headerlink" title="CP"></a>CP</h4><p>放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致，又比如跨行转账，一次转账请求要等待双方银行系统都完成整个事务才算完成。</p><h4 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h4><p>放弃分区容忍性，即不进行分区，不考虑由于网络不通或结点挂掉的问题，则可以实现一致性和可用性。那么系统将不是一个标准的分布式系统。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance）这三项中的两项。它可以作为我们进行架构设计、技术选型的考量标准。对于多数大型互联网应用的场景，结点众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9（99.99..%），并要达到良好的响应性能来提高用户体验，因此一般都会做出如下选择：保证P和A，舍弃C强一致，保证最终一性。</p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><h4 id="强一致性与最终一致性区别"><a href="#强一致性与最终一致性区别" class="headerlink" title="强一致性与最终一致性区别"></a>强一致性与最终一致性区别</h4><p>CAP理论告诉我们一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance）这三项中的两项，其中AP在实际应用中较多，AP即舍弃一致性，保证可用性和分区容忍性，但是在实际生产中很多场景都要实现一致性，比如前边我们举的例子主数据库向从数据库同步数据，即使不要一致性，但是最终也要将数据同步成功来保证数据一致，这种一致性和CAP中的一致性不同，CAP中的一致性要求在任何时间查询每个结点数据都必须一致，它强调的是强一致性，但是最终一致性是允许可以在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。</p><h4 id="BASE理论介绍"><a href="#BASE理论介绍" class="headerlink" title="BASE理论介绍"></a>BASE理论介绍</h4><p>BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“柔性事务”。</p><p>基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如，电商网站交易付款出</p><p>现问题了，商品依然可以正常浏览。</p><p>软状态:由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用性，如订单的”支付中”、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。</p><p>最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的”支付中”状态，最终会变</p><p>为“支付成功”或者”支付失败”，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。</p><h2 id="分布式事务解决方案之2PC"><a href="#分布式事务解决方案之2PC" class="headerlink" title="分布式事务解决方案之2PC"></a>分布式事务解决方案之2PC</h2><h3 id="什么是2PC"><a href="#什么是2PC" class="headerlink" title="什么是2PC"></a>什么是2PC</h3><p>2PC即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commitphase），2是指两个阶段，P是指准备阶段，C是指提交阶段。</p><h3 id="Seata方案"><a href="#Seata方案" class="headerlink" title="Seata方案"></a>Seata方案</h3><p>Seata是由阿里中间件团队发起的开源项目 Fescar，后更名为Seata，它是一个是开源的分布式事务框架。</p><p>传统2PC的问题在Seata中得到了解决，它通过对本地关系数据库的分支事务的协调来驱动完成全局事务，是工作在应用层的中间件。主要优点是性能较好，且不长时间占用连接资源，它以高效并且对业务0侵入的方式解决微服务场景下面临的分布式事务问题，它可提供AT模式(即2PC)及TCC模式的分布式事务解决方案。</p><p><strong>Seata的设计思想</strong></p><p>Seata的设计目标其一是对业务无侵入，因此从业务无侵入的2PC方案着手，在传统2PC的基础上演进，并解决2PC方案面临的问题。</p><p>Seata把一个分布式事务理解成一个包含了若干分支事务的全局事务。全局事务的职责是协调其下管辖的分支事务达成一致，要么一起成功提交，要么一起失败回滚。此外，通常分支事务本身就是一个关系数据库的本地事务，下图是全局事务与分支事务的关系图：</p><p><img src="/images/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image5.png"></p><p>与传统2PC的模型类似，Seata定义了3个组件来协议分布式事务的处理过程：</p><p><img src="/images/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image6.png"></p><p>Transaction Coordinator (TC)： 事务协调器，它是独立的中间件，需要独立部署运行，它维护全局事务的运行状态，接收TM指令发起全局事务的提交与回滚，负责与RM通信协调各各分支事务的提交或回滚。</p><p>Transaction Manager (TM)： 事务管理器，TM需要嵌入应用程序中工作，它负责开启一个全局事务，并最终</p><p>向TC发起全局提交或全局回滚的指令。</p><p>Resource Manager (RM)： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器TC的指令，驱动分</p><p>支（本地）事务的提交和回滚。</p><p><strong>Seata实现2PC与传统2PC的差别：</strong></p><p>架构层次方面，传统2PC方案的 RM 实际上是在数据库层，RM 本质上就是数据库自身，通过 XA 协议实现，而Seata的 RM 是以jar包的形式作为中间件层部署在应用程序这一侧的。</p><p>两阶段提交方面，传统2PC无论第二阶段的决议是commit还是rollback，事务性资源的锁都要保持到Phase2完成才释放。而Seata的做法是在Phase1 就将本地事务提交，这样就可以省去Phase2持锁的时间，整体提高效率。</p><h2 id="分布式事务解决方案之TCC"><a href="#分布式事务解决方案之TCC" class="headerlink" title="分布式事务解决方案之TCC"></a>分布式事务解决方案之TCC</h2><p>TCC是Try、Confirm、Cancel三个词语的缩写，TCC要求每个分支事务实现三个操作：预处理Try、确认</p><p>Confirm、撤销Cancel。Try操作做业务检查及资源预留，Confirm做业务确认操作，Cancel实现一个与Try相的</p><p>操作即回滚操作。TM首先发起所有的分支事务的try操作，任何一个分支事务的try操作执行失败，TM将会发起所</p><p>有分支事务的Cancel操作，若try操作全部成功，TM将会发起所有分支事务的Confirm操作，其中Confirm/Cancel操作若执行失败，TM会进行重试。</p><p><img src="/images/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image7.png"></p><p><img src="/images/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image8.png"></p><p>TCC分为三个阶段：</p><ol><li>Try 阶段是做业务检查(一致性)及资源预留(隔离)，此阶段仅是一个初步操作，它和后续的Confirm 一起才能真正构成一个完整的业务逻辑。</li><li>Confirm 阶段是做确认提交，Try阶段所有分支事务执行成功后开始执行 Confirm。通常情况下，采用TCC则<br>认为 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。若Confirm阶段真的出错了，需引<br>入重试机制或人工处理。</li><li>Cancel 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采<br>用TCC则认为Cancel阶段也是一定成功的。若Cancel阶段真的出错了，需引入重试机制或人工处理。</li><li>TM事务管理器<br>TM事务管理器可以实现为独立的服务，也可以让全局事务发起方充当TM的角色，TM独立出来是为了成为公<br>用组件，是为了考虑系统结构和软件复用。<br>TM在发起全局事务时生成全局事务记录，全局事务ID贯穿整个分布式事务调用链条，用来记录事务上下文，<br>追踪和记录状态，由于Confirm 和cancel失败需进行重试，因此需要实现为幂等，幂等性是指同一个操作无论请求多少次，其结果都相同。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果拿TCC事务的处理流程与2PC两阶段提交做比较，2PC通常都是在跨库的DB层面，而TCC则在应用层面的处理，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据操作的粒度，使得降低锁冲突、提高吞吐量成为可能。而不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。</p><h2 id="分布式事务解决方案之可靠消息最终一致性"><a href="#分布式事务解决方案之可靠消息最终一致性" class="headerlink" title="分布式事务解决方案之可靠消息最终一致性"></a>分布式事务解决方案之可靠消息最终一致性</h2><h3 id="RocketMQ实现方案"><a href="#RocketMQ实现方案" class="headerlink" title="RocketMQ实现方案"></a>RocketMQ实现方案</h3><p>RocketMQ 事务消息设计则主要是为了解决 Producer 端的消息发送与本地事务执行的原子性问题，RocketMQ 的设计中 broker 与 producer 端的双向通信能力，使得 broker 天生可以作为一个事务协调者存在；而RocketMQ本身提供的存储机制为事务消息提供了持久化能力；RocketMQ 的高可用机制以及可靠消息设计则为事务消息在系统发生异常时依然能够保证达成事务的最终一致性。在RocketMQ 4.3后实现了完整的事务消息，实际上其实是对本地消息表的一个封装，将本地消息表移动到了MQ内部，解决 Producer 端的消息发送与本地事务执行的原子性问题。</p><p><img src="/images/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image9.png"></p><ol><li>Producer 发送事务消息</li></ol><p>Producer （MQ发送方）发送事务消息至MQ Server，MQ Server将消息状态标记为Prepared（预备状态），注意此时这条消息消费者（MQ订阅方）是无法消费到的。</p><ol start="2"><li>MQ Server回应消息发送成功</li></ol><p>MQ Server接收到Producer 发送给的消息则回应发送成功表示MQ已接收到消息。</p><ol start="3"><li>Producer 执行本地事务</li></ol><p>Producer 端执行业务代码逻辑，通过本地数据库事务控制。</p><ol start="4"><li>消息投递</li></ol><p>若Producer 本地事务执行成功则自动向MQServer发送commit消息，MQ Server接收到commit消息后将消息状态标记为可消费，此时MQ订阅方即正常消费消息；若Producer 本地事务执行失败则自动向MQServer发送rollback消息，MQ Server接收到rollback消息后 将删除消息。MQ订阅方消费消息，消费成功则向MQ回应ack，否则将重复接收消息。这里ack默认自动回应，即程序执行正常则自动回应ack。</p><ol start="5"><li>事务回查</li></ol><p>如果执行Producer端本地事务过程中，执行端挂掉，或者超时，MQ Server将会不停的询问同组的其他 Producer来获取事务执行状态，这个过程叫事务回查。MQ Server会根据事务回查结果来决定是否投递消息。</p><p>以上主干流程已由RocketMQ实现，对用户侧来说，用户需要分别实现本地事务执行以及本地事务回查方法，因此只需关注本地事务的执行状态即可。</p><p>RoacketMQ提供RocketMQLocalTransactionListener接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface RocketMQLocalTransactionListener &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">‐ 发送prepare消息成功此方法被回调，该方法用于执行本地事务</span><br><span class="line">‐ @param msg 回传的消息，利用transactionId即可获取到该消息的唯一Id</span><br><span class="line">‐ @param arg 调用send方法时传递的参数，当send时候若有额外的参数可以传递到send方法中，这里能获取到</span><br><span class="line">‐ @return 返回事务状态，COMMIT：提交 ROLLBACK：回滚 UNKNOW：回调</span><br><span class="line">*&#x2F;</span><br><span class="line">RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg);</span><br><span class="line">&#x2F;**</span><br><span class="line">‐ @param msg 通过获取transactionId来判断这条消息的本地事务执行状态</span><br><span class="line">‐ @return 返回事务状态，COMMIT：提交 ROLLBACK：回滚 UNKNOW：回调</span><br><span class="line">*&#x2F;</span><br><span class="line">RocketMQLocalTransactionState checkLocalTransaction(Message msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送事务消息：</p><p>以下是RocketMQ提供用于发送事务消息的API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TransactionMQProducer producer &#x3D; new TransactionMQProducer(&quot;ProducerGroup&quot;);</span><br><span class="line">producer.setNamesrvAddr(&quot;127.0.0.1:10086&quot;);</span><br><span class="line">producer.start();</span><br><span class="line">&#x2F;&#x2F;设置TransactionListener实现</span><br><span class="line">producer.setTransactionListener(transactionListener）；</span><br><span class="line">&#x2F;&#x2F;发送事务消息</span><br><span class="line">SendResult sendResult &#x3D; producer.sendMessageInTransaction(msg, null);</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>可靠消息最终一致性就是保证消息从生产方经过消息中间件传递到消费方的一致性，本案例使用了RocketMQ作为消息中间件，RocketMQ主要解决了两个功能：</p><p>1、本地事务与消息发送的原子性问题。</p><p>2、事务参与方接收消息的可靠性。</p><p>可靠消息最终一致性事务适合执行周期长且实时性要求不高的场景。引入消息机制后，同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。</p><h2 id="分布式事务解决方案之最大努力通知"><a href="#分布式事务解决方案之最大努力通知" class="headerlink" title="分布式事务解决方案之最大努力通知"></a>分布式事务解决方案之最大努力通知</h2><h3 id="什么是最大努力通知"><a href="#什么是最大努力通知" class="headerlink" title="什么是最大努力通知"></a>什么是最大努力通知</h3><p>最大努力通知也是一种解决分布式事务的方案，下边是一个是充值的例子：</p><p><img src="/images/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image10.png"></p><p>交互流程:</p><p>1、账户系统调用充值系统接口</p><p>2、充值系统完成支付处理向账户系统发起充值结果通知若通知失败，则充值系统按策略进行重复通知</p><p>3、账户系统接收到充值结果通知修改充值状态。</p><p>4、账户系统未接收到通知会主动调用充值系统的接口查询充值结果。</p><p><strong>最大努力通知与可靠消息一致性有什么不同？</strong></p><p>1、解决方案思想不同</p><p>可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发到接收通知方，消息的可靠性关键由发起通知方来保证。最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，通知的可靠性关键在接收通知方。</p><p>2、两者的业务应用场景不同</p><p>可靠消息一致性关注的是交易过程的事务一致，以异步的方式完成交易。</p><p>最大努力通知关注的是交易后的通知事务，即将交易结果可靠的通知出去。</p><p>3、技术解决方向不同</p><p>可靠消息一致性要解决消息从发出到接收的一致性，即消息发出并且被接收到。</p><p>最大努力通知无法保证消息从发出到接收的一致性，只提供消息接收的可靠性机制。可靠机制是，最大努力的将消息通知给接收方，当消息无法被接收方接收时，由接收方主动查询消息（业务处理结果）。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p><img src="/images/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image11.png"></p><p>1、发起通知方将通知发给MQ。</p><p>使用普通消息机制将通知发给MQ。</p><p>注意：如果消息没有发出去可由接收通知方主动请求发起通知方查询业务执行结果。</p><p>2、接收通知方监听 MQ。</p><p>3、接收通知方接收消息，业务处理完成回应ack。</p><p>4、接收通知方若没有回应ack则MQ会重复通知。</p><p>MQ会按照间隔1min、5min、10min、30min、1h、2h、5h、10h的方式，逐步拉大通知间隔 （如果MQ采用</p><p>rocketMq，在broker中可进行配置），直到达到通知要求的时间窗口上限。</p><p>5、接收通知方可通过消息校对接口来校对消息的一致性。</p><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p>本方案也是利用MQ的ack机制，与方案1不同的是应用程序向接收通知方发送通知，如下图：</p><p><img src="/images/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image12.png"></p><p>交互流程如下：</p><p>1、发起通知方将通知发给MQ。</p><p>使用可靠消息一致方案中的事务消息保证本地事务与消息的原子性，最终将通知先发给MQ。</p><p>2、通知程序监听 MQ，接收MQ的消息。</p><p>方案1中接收通知方直接监听MQ，方案2中由通知程序监听MQ。通知程序若没有回应ack则MQ会重复通知。</p><p>3、通知程序通过互联网接口协议（如http、webservice）调用接收通知方案接口，完成通知。</p><p>通知程序调用接收通知方案接口成功就表示通知成功，即消费MQ消息成功，MQ将不再向通知程序投递通知消</p><p>息。</p><p>4、接收通知方可通过消息校对接口来校对消息的一致性。</p><p><strong>方案1和方案2的不同点：</strong></p><p>1、方案1中接收通知方与MQ接口，即接收通知方案监听 MQ，此方案主要应用与内部应用之间的通知。</p><p>2、方案2中由通知程序与MQ接口，通知程序监听MQ，收到MQ的消息后由通知程序通过互联网接口协议调用接收通知方。此方案主要应用于外部应用之间的通知，例如支付宝、微信的支付结果通知。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h2&gt;&lt;h3 id=&quot;什么是事务&quot;&gt;&lt;a href=&quot;#什么是事务&quot; class=&quot;headerlink&quot; title=&quot;什么是事务&quot;&gt;</summary>
      
    
    
    
    
    <category term="分布式事务" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式开发板、Windows、Ubuntu三者网络互通</title>
    <link href="http://example.com/2020/09/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/"/>
    <id>http://example.com/2020/09/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/</id>
    <published>2020-09-27T05:18:06.000Z</published>
    <updated>2020-09-27T06:18:08.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发板、windows、Ubuntu互相ping通教程-不借助外部网络"><a href="#开发板、windows、Ubuntu互相ping通教程-不借助外部网络" class="headerlink" title="开发板、windows、Ubuntu互相ping通教程(不借助外部网络)"></a>开发板、windows、Ubuntu互相ping通教程(不借助外部网络)</h1><h2 id="Ubuntu设置"><a href="#Ubuntu设置" class="headerlink" title="Ubuntu设置"></a>Ubuntu设置</h2><h3 id="①打开VMware软件"><a href="#①打开VMware软件" class="headerlink" title="①打开VMware软件"></a>①打开VMware软件</h3><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image001.png" alt="img"></p><h3 id="②点击更改设置，没有这个则跳过这步直接看③"><a href="#②点击更改设置，没有这个则跳过这步直接看③" class="headerlink" title="②点击更改设置，没有这个则跳过这步直接看③"></a>②点击更改设置，没有这个则跳过这步直接看③</h3><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image002.png" alt="img"></p><h3 id="③设置桥接的网卡"><a href="#③设置桥接的网卡" class="headerlink" title="③设置桥接的网卡"></a>③设置桥接的网卡</h3><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image003.png" alt="img"></p><h3 id="④打开Ubuntu虚拟机设置，设置网络适配器为桥接模式"><a href="#④打开Ubuntu虚拟机设置，设置网络适配器为桥接模式" class="headerlink" title="④打开Ubuntu虚拟机设置，设置网络适配器为桥接模式"></a>④打开Ubuntu虚拟机设置，设置网络适配器为桥接模式</h3><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image004.png" alt="img"></p><h3 id="⑤打开终端给Ubuntu配置IP"><a href="#⑤打开终端给Ubuntu配置IP" class="headerlink" title="⑤打开终端给Ubuntu配置IP"></a>⑤打开终端给Ubuntu配置IP</h3><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image005.png" alt="img"></p><h2 id="开发板设置"><a href="#开发板设置" class="headerlink" title="开发板设置"></a>开发板设置</h2><h3 id="①启动开发板进入系统后，在命令行输入：ifconfig-eth0-up-启动网卡"><a href="#①启动开发板进入系统后，在命令行输入：ifconfig-eth0-up-启动网卡" class="headerlink" title="①启动开发板进入系统后，在命令行输入：ifconfig eth0 up 启动网卡"></a>①启动开发板进入系统后，在命令行输入：ifconfig eth0 up 启动网卡</h3><h3 id="②然后在命令行输入：ifconfig-eth0-192-168-2-5给开发板eth0网卡配置ip（注：配置的ip和Windows、ubuntu在同一网段即可）"><a href="#②然后在命令行输入：ifconfig-eth0-192-168-2-5给开发板eth0网卡配置ip（注：配置的ip和Windows、ubuntu在同一网段即可）" class="headerlink" title="②然后在命令行输入：ifconfig eth0 192.168.2.5给开发板eth0网卡配置ip（注：配置的ip和Windows、ubuntu在同一网段即可）"></a>②然后在命令行输入：ifconfig eth0 192.168.2.5给开发板eth0网卡配置ip（注：配置的ip和Windows、ubuntu在同一网段即可）</h3><h2 id="3-Windows设置"><a href="#3-Windows设置" class="headerlink" title="3.Windows设置"></a>3.Windows设置</h2><h3 id="①把开发板用网线连接到电脑上"><a href="#①把开发板用网线连接到电脑上" class="headerlink" title="①把开发板用网线连接到电脑上"></a>①把开发板用网线连接到电脑上</h3><h3 id="②当开发板进入系统后，打开网络和共享中心"><a href="#②当开发板进入系统后，打开网络和共享中心" class="headerlink" title="②当开发板进入系统后，打开网络和共享中心"></a>②当开发板进入系统后，打开网络和共享中心</h3><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image006.png" alt="img"></p><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image007.png" alt="img"></p><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image008.png" alt="img"></p><p>  <strong>在同一个网段，所以网关可以不配</strong></p><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image009.png" alt="img"></p><h2 id="完成上面的设置即可三者互相ping通了"><a href="#完成上面的设置即可三者互相ping通了" class="headerlink" title="完成上面的设置即可三者互相ping通了"></a>完成上面的设置即可三者互相ping通了</h2><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image010.png" alt="img"></p><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image011.png" alt="img"></p><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image012.png" alt="img"></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>上面的方法有个缺点就是：当拔掉连接开发板的网线时，Windows和Ubuntu之间就无法ping通，即无法使用FTP软件相互传输文件。</p><p><strong>下面按照我的设置就可以解决这个问题</strong></p><h3 id="①打开虚拟机设置，添加一个网络适配器，选择主机模式"><a href="#①打开虚拟机设置，添加一个网络适配器，选择主机模式" class="headerlink" title="①打开虚拟机设置，添加一个网络适配器，选择主机模式"></a>①打开虚拟机设置，添加一个网络适配器，选择主机模式</h3><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image013.png" alt="img"></p><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image014.png" alt="img"></p><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image015.png" alt="img"></p><h2 id="②启动虚拟机，打开终端输入ifconfig查看ip"><a href="#②启动虚拟机，打开终端输入ifconfig查看ip" class="headerlink" title="②启动虚拟机，打开终端输入ifconfig查看ip"></a>②启动虚拟机，打开终端输入ifconfig查看ip</h2><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image016.png" alt="img"></p><h3 id="③测试结果可以连通"><a href="#③测试结果可以连通" class="headerlink" title="③测试结果可以连通"></a>③测试结果可以连通</h3><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image017.png" alt="img"></p><p><img src="/images/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E3%80%81Windows%E3%80%81Ubuntu%E4%B8%89%E8%80%85%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A/clip_image018.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开发板、windows、Ubuntu互相ping通教程-不借助外部网络&quot;&gt;&lt;a href=&quot;#开发板、windows、Ubuntu互相ping通教程-不借助外部网络&quot; class=&quot;headerlink&quot; title=&quot;开发板、windows、Ubuntu互相pi</summary>
      
    
    
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Centos8安装Docker</title>
    <link href="http://example.com/2020/09/25/Centos8%E5%AE%89%E8%A3%85Docker/"/>
    <id>http://example.com/2020/09/25/Centos8%E5%AE%89%E8%A3%85Docker/</id>
    <published>2020-09-25T05:24:36.000Z</published>
    <updated>2020-09-27T06:17:30.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Centos8默认使用了Podman代替了Docker,被称为下一代容器技术，但现在市面上还是使用Docker的比较多。Docker官方推荐的Linux的系统是Ubuntu的，生产环境建议安装在Ubuntu上，性能会好点。由于我的电脑只安装了Centos8，所以我就在Centos8下演示如何安装Docker。</p><h1 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h1><ul><li><p>先安装yum-utils包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure><p>看到如下图所示的<strong>Complete！</strong>表示安装成功</p></li></ul><img src="/images/Centos8安装docker/image-20200925140551493.png" alt="image-20200925140551493" style="zoom:50%;" /><ul><li><p>设置Docker仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>这时遇到了一个错误：<img src="/images/Centos8%E5%AE%89%E8%A3%85docker/image-20200925174856466.png" alt="image-20200925174856466"></p></li></ul><p><strong>解决办法</strong>：升级网络安全服务即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum update nss</span><br></pre></td></tr></table></figure><p>再执行刚才的命令：<img src="/images/Centos8%E5%AE%89%E8%A3%85docker/image-20200925175246455.png" alt="image-20200925175246455"></p><p>没有出现报错证明安装成功</p><ul><li><p>安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io --nobest</span><br></pre></td></tr></table></figure><p>这时又出现了一个错误：<img src="/images/Centos8安装docker/image-20200925213802731.png" alt="image-20200925213802731" style="zoom:50%;" /></p></li></ul><p>这应该是防火墙没有允许443端口通过，我们先看防火墙端口列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure><p><img src="/images/Centos8%E5%AE%89%E8%A3%85docker/image-20200925221357023.png" alt="image-20200925221357023"></p><p>发现防火墙白名单没有443端口，下面我们设置一下让防火墙允许443端口通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ firewall-cmd --zone=public --add-port=443/tcp --permanent</span><br></pre></td></tr></table></figure><p>执行以下命令使配置立即生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ firewall-cmd --reload </span><br></pre></td></tr></table></figure><p>再执行安装Docker的命令:<img src="/images/Centos8%E5%AE%89%E8%A3%85docker/image-20200925233441937.png" alt="image-20200925233441937"></p><p>看到Complete就证明安装成功了</p><h1 id="启动测试Docker容器"><a href="#启动测试Docker容器" class="headerlink" title="启动测试Docker容器"></a>启动测试Docker容器</h1><ul><li><p>先设置ustc镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir /etc/docker  //创建Docker配置目录</span><br><span class="line">$ sudo vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>在该文件中输入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动Docker容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker //启动Docker</span><br><span class="line">$ sudo systemctl status docker //查看Docker容器运行状态</span><br></pre></td></tr></table></figure><img src="/images/Centos8安装docker/image-20200926104911873.png" alt="image-20200926104911873" style="zoom:50%;" /></li></ul><p>Docker常用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop docker //停止Docker</span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker //开机启动Docker</span><br><span class="line">$ sudo docker info //查看Docker信息</span><br><span class="line">$ sudo docker images //查看Docker本地镜像文件信息</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Centos8默认使用了Podman代替了Docker,被称为下一代容器技术，但现在市面上还是使用Docker的比较多。Docker官方推荐</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github免费搭建个人博客</title>
    <link href="http://example.com/2020/09/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2020/09/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2020-09-21T06:08:40.000Z</published>
    <updated>2020-09-27T05:36:16.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-Github免费搭建个人博客"><a href="#Hexo-Github免费搭建个人博客" class="headerlink" title="Hexo+Github免费搭建个人博客"></a>Hexo+Github免费搭建个人博客</h1><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><ul><li><p>打开node.js中文网(<a href="http://nodejs.cn/download/),%E6%A0%B9%E6%8D%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E8%BD%BD%E7%9B%B8%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AE%89%E8%A3%85%E5%8C%85">http://nodejs.cn/download/),根据自己的操作系统下载相对应的安装包</a></p></li><li><p>下载完成后双击安装包进行安装</p></li></ul><img src="/images/个人博客搭建/image-20200922160749679.png" alt="image-20200922160749679" style="zoom:50%;" /><p>打开终端输入node -v 和npm -v</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure><img src="/images/个人博客搭建/image-20200922161627433.png" alt="image-20200922161627433" style="zoom:50%;" /><p>能看到版本号就说明安装成功了！</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><ul><li>安装hexo</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -i  //切换管理员</span><br><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><ul><li>检查是否安装成功</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure><ul><li>能看到以下的信息就证明安装成功了</li></ul><img src="/images/个人博客搭建/image-20200922161644391.png" alt="image-20200922161644391" style="zoom:50%;" /><ul><li><p>如果你没有科学上网的环境，用npm安装还是挺慢的。那么可以先安装cnpm，然后再安装hexo</p></li><li><p>先安装cnpm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li><p>再安装hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install -g hexo </span><br></pre></td></tr></table></figure></li></ul><h2 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h2><ul><li><p>初始化hexo博客</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure><img src="/images/个人博客搭建/image-20200922161744907.png" alt="image-20200922161744907" style="zoom:50%;" /></li></ul><ul><li><p>切换blog目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br></pre></td></tr></table></figure></li><li><p>启动hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20200922161754633.png" alt="image-20200922161754633"></p><ul><li><p>在浏览器输入：<a href="http://localhost:4000/">http://localhost:4000</a></p></li><li><p>能看到这个页面就证明初始化成功了</p><p><img src="/images/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20200922161805338.png" alt="image-20200922161805338"></p></li></ul><h2 id="部署到GitHub上"><a href="#部署到GitHub上" class="headerlink" title="部署到GitHub上"></a>部署到GitHub上</h2><ul><li><p>打开GitHub，登录自己账号。在首页右上角新建一个新仓库</p><p><img src="/images/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20200921162907062-0678549.png" alt="image-20200921162907062-0678549"></p></li><li><p>这里要特别==<strong>注意</strong>==，仓库命名必须是:==<strong>你的同户名.github.io</strong>==</p></li></ul><p><img src="/images/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20200921162920329-0678549.png" alt="image-20200921162920329-0678549"></p><ul><li><p>在blog目录下安装git插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><img src="/images/个人博客搭建/image-20200922161917878.png" alt="image-20200922161917878" style="zoom:50%;" /></li><li><p>配置 _config.yml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim _config.yml</span></span><br></pre></td></tr></table></figure><p>编辑deploy(==<strong>注意</strong>==：冒号后面有空格，这是yml格式规范)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span> </span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repo:</span> <span class="string">https://github.com/kakiu23/kakiu23.github.io.git</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p><img src="/images/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20200921222434166.png" alt="image-20200921222434166"></p><ul><li>保存退出</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wq!</span><br></pre></td></tr></table></figure><ul><li><p>部署到GitHub</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><ul><li>输入GitHub用户名和密码</li></ul></li></ul><pre><code>&lt;img src=&quot;/images/个人博客搭建/image-20200921222750800.png&quot; alt=&quot;image-20200921222750800&quot; style=&quot;zoom:50%;&quot; /&gt;</code></pre><ul><li><p>部署成功我们打开GitHub仓库看看</p><p><img src="/images/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20200921163020158-0678549.png" alt="image-20200921163020158-0678549"></p></li><li><p>能看到上面这些就是部署成功了，我们接着在浏览器输入<strong>仓库的名称</strong>就是访问了，我的仓库名称就是:kakiu23.github.io</p></li></ul><p><img src="/images/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20200921163043998-0678549.png" alt="image-20200921163043998-0678549"></p><p>​    已经能通过仓库名正常访问了。</p><ul><li>到这里就基本安装完成了。</li></ul><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><ul><li><p>上GitHub找自己喜欢主题，然后通过git clone到blog/themes目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly //下载主题</span><br><span class="line">$ npm i hexo-theme-butterfly  //安装主题</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>修改 _config.yml，修改你要换的主题名称</p><img src="/images/个人博客搭建/image-20200921163239630.png" alt="image-20200921163239630" style="zoom:50%;" /></li></ul><ul><li><p>重新生成发布</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean //清除</span><br><span class="line">$ hexo g     //重新生成</span><br><span class="line">$ hexo d     //部署</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>遇到的问题</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改主题后启动如果报如下错误：</span><br><span class="line"><span class="keyword">extends</span> includes/layout.pug block content <span class="keyword">include</span> includes/recent-posts.pug <span class="keyword">include</span> includes/partial</span><br></pre></td></tr></table></figure><ul><li><p>解决办法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">则执行如下命令可解决：</span><br><span class="line">npm install --save hexo-renderer-jade hexo-<span class="built_in">generator</span>-feed hexo-<span class="built_in">generator</span>-sitemap hexo-browsersync hexo-<span class="built_in">generator</span>-archive</span><br></pre></td></tr></table></figure></li></ul></li><li><p>重新清除缓存，生成，发布；效果如下</p><p><img src="/images/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20200921163254391-0698691.png" alt="image-20200921163254391"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo-Github免费搭建个人博客&quot;&gt;&lt;a href=&quot;#Hexo-Github免费搭建个人博客&quot; class=&quot;headerlink&quot; title=&quot;Hexo+Github免费搭建个人博客&quot;&gt;&lt;/a&gt;Hexo+Github免费搭建个人博客&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    
    <category term="个人博客搭建" scheme="http://example.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
</feed>
